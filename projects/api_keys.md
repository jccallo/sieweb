# Api Keys

```sql
CREATE TABLE api_keys (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

    -- Dueño de la key
    owner_type VARCHAR(50) NOT NULL,
    owner_id BIGINT UNSIGNED NOT NULL,

    -- Información descriptiva
    name VARCHAR(255) NOT NULL,

    -- Seguridad
    key_hash CHAR(64) NOT NULL UNIQUE,

    -- Permisos
    abilities JSON NOT NULL,

    -- Uso y expiración
    last_used_at TIMESTAMP NULL,
    expires_at TIMESTAMP NULL,

    -- Estado
    is_active BOOLEAN NOT NULL DEFAULT TRUE,

    -- Control de empresa
    created_by BIGINT UNSIGNED NULL,
    revoked_at TIMESTAMP NULL,
    rate_limit INT NULL,
    allowed_ips JSON NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,

    -- Índices recomendados
    INDEX idx_owner (owner_type, owner_id),
    INDEX idx_active (is_active),
    INDEX idx_expires_at (expires_at)
);

```
Mejorado api_keys
```sql
CREATE TABLE api_keys (
    id BIGINT UNSIGNED AUTO_INCREMENT PRIMARY KEY,

    -- Dueño de la key
    owner_type VARCHAR(50) NOT NULL,
    owner_id BIGINT UNSIGNED NOT NULL,

    -- Información descriptiva
    name VARCHAR(255) NOT NULL,

    -- Seguridad
    key_hash CHAR(64) NOT NULL UNIQUE,

    -- Permisos
    abilities JSON NOT NULL,

    -- Uso y expiración
    last_used_at TIMESTAMP NULL,
    expires_at TIMESTAMP NULL,

    -- Estado
    is_active BOOLEAN NOT NULL DEFAULT TRUE,

    -- Control de empresa
    created_by BIGINT UNSIGNED NULL,
    revoked_at TIMESTAMP NULL,

    -- Rate limit
    rate_limit INT NULL,          -- máximo de requests
    window_seconds INT NOT NULL DEFAULT 60, -- duración de ventana

    allowed_ips JSON NULL,

    -- Timestamps
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,

    -- Índices recomendados
    INDEX idx_owner (owner_type, owner_id),
    INDEX idx_active (is_active),
    INDEX idx_expires_at (expires_at)
);

```

api_key_rate_limits
```sql
CREATE TABLE api_key_rate_limits (
    api_key_id BIGINT UNSIGNED PRIMARY KEY,
    request_count INT UNSIGNED NOT NULL DEFAULT 0,
    window_start DATETIME NOT NULL,

    CONSTRAINT fk_rate_limit_api_key
        FOREIGN KEY (api_key_id)
        REFERENCES api_keys(id)
        ON DELETE CASCADE
);
```

Tabla final para Firebird (Rate limit incluido)
```sql
CREATE TABLE api_keys (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    owner_type VARCHAR(50) NOT NULL,
    owner_id BIGINT NOT NULL,
    name VARCHAR(255) NOT NULL,
    key_hash CHAR(64) NOT NULL,
    abilities BLOB SUB_TYPE 1 SEGMENT SIZE 80 NOT NULL,
    last_used_at TIMESTAMP,
    expires_at TIMESTAMP,
    is_active SMALLINT DEFAULT 1 NOT NULL,
    created_by BIGINT,
    revoked_at TIMESTAMP,
    rate_limit INT,                       -- máximo requests por ventana
    window_seconds INT DEFAULT 60 NOT NULL, 
    request_count INT DEFAULT 0 NOT NULL,  -- contador actual
    window_start TIMESTAMP DEFAULT CURRENT_TIMESTAMP NOT NULL, -- inicio de ventana
    allowed_ips BLOB SUB_TYPE 1 SEGMENT SIZE 80,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP,
    CONSTRAINT uq_key_hash UNIQUE (key_hash)
);

-- Índices recomendados
CREATE INDEX idx_owner ON api_keys(owner_type, owner_id);
CREATE INDEX idx_active ON api_keys(is_active);
```

propuesta de rate limit en memoria
```ts
// rate-limit.service.ts
interface RateLimitData {
  count: number;
  windowEnd: number;
}

const limits = new Map<string, RateLimitData>();

export class RateLimitService {
  static defaultRateLimit = 100;          // Requests por ventana
  static defaultWindowSeconds = 60;       // Duración ventana en segundos
  static alertThreshold = 10_000;         // Alerta si supera req/min
  static maxKeys = 50_000;                // Máximo de keys en memoria

  /**
   * Check rápido en memoria
   */
  static check(apiKey: string, rateLimit = RateLimitService.defaultRateLimit, windowSeconds = RateLimitService.defaultWindowSeconds): boolean {
    const now = Date.now();
    let data = limits.get(apiKey);

    if (!data || now > data.windowEnd) {
      data = { count: 1, windowEnd: now + windowSeconds * 1000 };
      limits.set(apiKey, data);
      RateLimitService.ensureMaxKeys();
      return true;
    }

    if (data.count < rateLimit) {
      data.count += 1;
      RateLimitService.handleAlert(apiKey, data.count);
      return true;
    }

    return false; // Límite superado
  }

  /**
   * Manejo de alertas de tráfico extremo
   */
  private static handleAlert(apiKey: string, count: number) {
    if (count > RateLimitService.alertThreshold) {
      console.warn(`ALERTA: API key ${apiKey} superó ${RateLimitService.alertThreshold} req/min en este nodo`);
    }
  }

  /**
   * Limitar el tamaño del Map para no crecer indefinidamente
   */
  private static ensureMaxKeys() {
    if (limits.size <= RateLimitService.maxKeys) return;

    // Borrar keys más antiguas hasta reducir tamaño
    const keys = Array.from(limits.keys());
    const removeCount = limits.size - RateLimitService.maxKeys;
    for (let i = 0; i < removeCount; i++) {
      limits.delete(keys[i]);
    }
  }
}
```
